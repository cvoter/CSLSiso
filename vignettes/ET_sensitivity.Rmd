---
title: "ET Sensitivity"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Put the title of your vignette here}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(devtools)
library(isoH2Obudget)
library(cslsdata)
library(extrafont)
library(ggplot2)
library(dplyr)
library(lubridate)
library(reshape2)
```

```{r ETcalc, echo=FALSE, eval=TRUE, warning=FALSE, message=FALSE}
plot_lake_ET <- function(lake){
  data("weather", package = "cslsdata")
  if (lake == "Pleasant") {
    data("psnt_lst", package = "cslsdata"); lst <- psnt_lst
    data("psnt_isotopes", package = "cslsdata"); isotopes <- psnt_isotopes
    data("psnt_lake_levels", package = "cslsdata"); lake_levels <- psnt_lake_levels
    data("psnt_gw_levels", package = "cslsdata"); gw_levels <- psnt_gw_levels
    data("psnt_stage_vol", package = "cslsdata"); stage_vol <- psnt_stage_vol
    data("psnt_dictionary", package = "cslsdata"); site_dictionary <- psnt_dictionary
  } else if (lake == "Long") {
    data("long_lst", package = "cslsdata"); lst <- long_lst
    data("long_isotopes", package = "cslsdata"); isotopes <- long_isotopes
    data("long_lake_levels", package = "cslsdata"); lake_levels <- long_lake_levels
    data("long_gw_levels", package = "cslsdata"); gw_levels <- long_gw_levels
    data("long_stage_vol", package = "cslsdata"); stage_vol <- long_stage_vol
    data("long_dictionary", package = "cslsdata"); site_dictionary <- long_dictionary
  } else if (lake == "Plainfield") {
    data("pfl_lst", package = "cslsdata"); lst <- pfl_lst
    data("pfl_isotopes", package = "cslsdata"); isotopes <- pfl_isotopes
    data("pfl_lake_levels", package = "cslsdata"); lake_levels <- pfl_lake_levels
    data("pfl_gw_levels", package = "cslsdata"); gw_levels <- pfl_gw_levels
    data("pfl_stage_vol", package = "cslsdata"); stage_vol <- pfl_stage_vol
    data("pfl_dictionary", package = "cslsdata"); site_dictionary <- pfl_dictionary
  }

timeseries <- find_overlap_timeseries(weather, lst, isotopes, lake_levels,
                                      gw_levels)
timeseries <- as_datetime(timeseries)

# Monthly summary
monthly_weather   <- summarise_weather(weather, lst, stage_vol, site_dictionary, 
                                       timeseries, wind_elev = 3, z0 = 0.02, 
                                       Lz = 90, lake_albedo = 0.08)

monthly_ET  <- monthly_weather %>%
               select(date = .data$date, 
                      ET = .data$ET_mm)

return(monthly_ET)
}
```

## Overview

This illustrates the differences between using **FAO Penman-Monteith Reference
ET**, which is what Hancock Station includes in their weather data, vs.
calculating **lake evaporation** for an open body of water. I don't think FAO
Penman-Montheith Reference ET is appropriate for a lake because it represents ET
from a cropped surface. An open body of water has a very difference
resistance to ET than a leaf.

The method I use to calculate lake evaporation is based on McJannet et al.
(2008), as presented in the overview of methods for estimating
evaporation by McMahon et al. (2013). McMahon et al. (2013) suggests that this
method is appropriate for a range of water bodies (irrigation channel, shallow
and deep lakes) and they provide a worked example which I used to validate my
code. There are 1-2 other approaches listed as appropriate for a "shallow" lake
which I could check, but it would take more time to code that up and it's less
clear to me that they work for the range of lake sizes in the CSLS.

There are three ways that the current code could be improved for the CSLS
lakes:

* Use a dynamic time series of water depth and lake surface area. For time
reasons, I simply threw in a static surface area and depth for each lake.
* Use a dynamic time series of daily lake surface temperature. I'm currently
initiating a daily time series of lake surface temperature with the first
field-based measurement, then letting the estimation approach take it away from
there.
* Use a daily lake temperature profile to calculate heat flux out of the lake.

### References

McMahon, T. A., Peel, M. C., Lowe, L., Srikanthan, R., and McVicar, T. R.:
Estimating actual, potential, reference crop and pan evaporation using standard
meteorological data: a pragmatic synthesis, Hydrol. Earth Syst. Sci., 17,
1331â€“1363, 2013.

McJannet, D. L., Webster, I. T., Stenson, M. P., and Sherman, B. S.: Estimating
open water evaporation for the Murray-Darling Basin. A report to the Australian
Government from the CSIRO Murray-Darling Basin Sustainable Yields Project,
CSIRO, Australia, 50 pp., 2008.

## Lake Comparisons

When the FAO Penman-Monteith method is compared to the lake evaporation method,
it's clear that this does make a big difference. At a gut check level, the **new
timeseries of lake ET makes more sense** to me. Each lake has a slightly
different evaporation rate, driven by the size of the water body. Pleasant Lake,
the deepest lake, can retain more heat so variations in ET are more muted and
slightly shifted toward the fall when compared with ET patterns at Long Lake and
Plainfield Lake. Lake ET rates tend to be higher than FAO reference ET rates
throughout the entire year (except maybe February, and except Pleasant in early
spring), which also makes sense since resistance to evaporation from a water
body is much lower than resistance to evaporation from a leaf, provided the lake
is sufficiently warm.

```{r ETplot, echo=FALSE, eval=TRUE, warning=FALSE, message=FALSE, fig.width = 7, fig.height = 5}
psnt_ET <- plot_lake_ET("Pleasant")
long_ET <- plot_lake_ET("Long")
pfl_ET  <- plot_lake_ET("Plainfield")

colnames(psnt_ET) <- c("date", "Pleasant")
colnames(long_ET) <- c("date", "Long")
colnames(pfl_ET) <- c("date", "Plainfield")

monthly_ET <- merge(psnt_ET, long_ET)
monthly_ET <- merge(monthly_ET, pfl_ET)


data("weather_rpet", package = "cslsdata")
ET_hck <- weather_rpet %>%
          group_by(date = floor_date(date, unit = "month")) %>%
          summarise(ET_hck = sum(ET))

monthly_ET <- merge(monthly_ET, ET_hck)
monthly_ET <- monthly_ET[2:(nrow(monthly_ET)-1), ]
melted_ET  <- melt(monthly_ET, id.vars = "date")

plot_ET <- ggplot(data = melted_ET, 
                  aes(x = as.Date(date), y = value, fill = variable)) +
           geom_col(position = "dodge") +
           scale_y_continuous(limits = c(0, 200),
                              expand = c(0, 0)) +
           scale_x_date(date_breaks = "2 months",
                        date_labels = "%b %y") +
           scale_fill_manual(name = "Flux",
                             values = c("steelblue4", 
                                        "steelblue3", 
                                        "steelblue2", 
                                        "orchid4"),
                             breaks = c("Pleasant", 
                                        "Long", 
                                        "Plainfield", 
                                        "ET_hck"),
                             labels = c("Pleasant", 
                                        "Long", 
                                        "Plainfield", 
                                        "FAO ET0")) +
           labs(x = "", y = "ET (mm)") +
           theme_bw() + 
           theme(text = element_text(family = "Segoe UI Semilight"))
plot_ET
```

## Session info
The version of R and the versions of packages in use when this R Markdown file
was created are listed here:

```{r session_info, include=TRUE, echo=TRUE, results='markup'}
devtools::session_info()
```
